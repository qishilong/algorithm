# 50. Pow(x, n)

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。

**示例 1：**

```
输入：x = 2.00000, n = 10
输出：1024.00000
```

**示例 2：**

```
输入：x = 2.10000, n = 3
输出：9.26100
```

**示例 3：**

```
输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
```

**提示：**

-   `-100.0 < x < 100.0`
-   `-231 <= n <= 231-1`
-   `n` 是一个整数
-   要么 `x` 不为零，要么 `n > 0` 。
-   `-104 <= xn <= 104`



## 思路

### 方法一

#### 快速幂+递归

![image-20260205191211351](https://qiniucloud.qishilong.space/images20260205191211627.png)

#### 代码

```js
/**
 * 1. 快速幂+递归
 * 快速幂算法的本质是分治算法。
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function (x, n) {
  if (typeof x !== 'number' || typeof n !== 'number') {
    return;
  }

  if (x === 0) {
    return 0;
  }

  if (n === 0) {
    return 1;
  }

  /**
   * 分治求乘积
   * @param {number} x
   * @param {number} decomposeN
   * @returns
   */
  const decompose = (x, decomposeN) => {
    if (decomposeN === 0) {
      return 1;
    }

    const y = decompose(x, Math.floor(decomposeN / 2));

    return decomposeN % 2 === 0 ? y * y : y * y * x;
  };

  return n >= 0 ? decompose(x, n) : 1 / decompose(x, -n);
};
```

### 方法二

#### 快速幂 + 迭代

![image-20260205191342600](https://qiniucloud.qishilong.space/images20260205191342655.png)

#### 代码

```js
/**
 * 2. 快速幂+迭代
 * 快速幂算法的本质是分治算法。
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function (x, n) {
  if (typeof x !== 'number' || typeof n !== 'number') {
    return;
  }

  if (x === 0) {
    return 0;
  }

  if (n === 0) {
    return 1;
  }

  /**
   * 分治求乘积
   * @param {number} x
   * @param {number} decomposeN
   * @returns
   */
  const decompose = (x, decomposeN) => {
    let res = 1,
      xContribute = x; // 贡献的初始值为 x

    // 在对 decomposeN 进行二进制拆分的同时计算答案
    while (decomposeN > 0) {
      if (decomposeN % 2 === 1) {
        // 如果 decomposeN 二进制表示的最低位为 1，那么需要计入贡献
        res *= xContribute;
      }

      // 将贡献不断地平方
      xContribute *= xContribute;

      // 舍弃 decomposeN 二进制表示的最低位，这样我们每次只要判断最低位即可
      decomposeN = Math.floor(decomposeN / 2);
    }

    return res;
  };

  return n >= 0 ? decompose(x, n) : 1 / decompose(x, -n);
};
```

## 代码

### 快速幂+递归

```js
/**
 * 1. 快速幂+递归
 * 快速幂算法的本质是分治算法。
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function (x, n) {
  if (typeof x !== 'number' || typeof n !== 'number') {
    return;
  }

  if (x === 0) {
    return 0;
  }

  if (n === 0) {
    return 1;
  }

  /**
   * 分治求乘积
   * @param {number} x
   * @param {number} decomposeN
   * @returns
   */
  const decompose = (x, decomposeN) => {
    if (decomposeN === 0) {
      return 1;
    }

    const y = decompose(x, Math.floor(decomposeN / 2));

    return decomposeN % 2 === 0 ? y * y : y * y * x;
  };

  return n >= 0 ? decompose(x, n) : 1 / decompose(x, -n);
};
```

### 快速幂 + 迭代

```ts
/**
 * 2. 快速幂+迭代
 * 快速幂算法的本质是分治算法。
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function (x, n) {
  if (typeof x !== 'number' || typeof n !== 'number') {
    return;
  }

  if (x === 0) {
    return 0;
  }

  if (n === 0) {
    return 1;
  }

  /**
   * 分治求乘积
   * @param {number} x
   * @param {number} decomposeN
   * @returns
   */
  const decompose = (x, decomposeN) => {
    let res = 1,
      xContribute = x; // 贡献的初始值为 x

    // 在对 decomposeN 进行二进制拆分的同时计算答案
    while (decomposeN > 0) {
      if (decomposeN % 2 === 1) {
        // 如果 decomposeN 二进制表示的最低位为 1，那么需要计入贡献
        res *= xContribute;
      }

      // 将贡献不断地平方
      xContribute *= xContribute;

      // 舍弃 decomposeN 二进制表示的最低位，这样我们每次只要判断最低位即可
      decomposeN = Math.floor(decomposeN / 2);
    }

    return res;
  };

  return n >= 0 ? decompose(x, n) : 1 / decompose(x, -n);
};
```
