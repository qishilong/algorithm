# 理论基础

## 二叉树的种类

在我们解题过程中，二叉树主要分为两类：满二叉树和完全二叉树。

### 满二叉树

>   如果一棵树只有度为 0 的结点和度为 2 的结点，并且度为 0 的结点在同一层上，则这棵二叉树为满二叉树。

如图所示：

![img](https://qiniucloud.qishilong.space/images/20200806185805576.png)

这棵二叉树为满二叉树，也可以说是深度为 k，有 2^k - 1 个节点的二叉树。

### 完全二叉树

>   在完全二叉树中，除了最底层节点可能没填满外，其余每层节点都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h 从 1 开始），则该层包含 1 ～ 2^(h - 1) 个节点。

![img](https://qiniucloud.qishilong.space/images/20200920221638903.png)

优先级队列其实就是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。

### 二叉搜索树

二叉搜索树是有数值的，二叉搜索树是一棵有序树

>   -   若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
>   -   若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
>   -   它的左、右子树也分别为二叉排序树。

下面这两棵树都是搜索树：

![img](https://qiniucloud.qishilong.space/images/20200806190304693.png)

### 平衡二叉搜索树

>   又被称为 AVL 树，且具有以下性质：
>
>   它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一个平衡二叉树。

![img](https://qiniucloud.qishilong.space/images/20200806190511967.png)

最后一棵不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了 1。

## 二叉树的存储方式

>   二叉树可以链式存储，也可以顺序存储。

链式存储方式就用指针，顺序存储方式就用数组。

顾名思义顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。

链式存储如图：

![img](https://qiniucloud.qishilong.space/images/2020092019554618.png)

顺序存储如图：

![img](https://qiniucloud.qishilong.space/images/20200920200429452.png)

其实就是用数组来存储二叉树。

遍历方式：

如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。

链式存储表示的二叉树更有利于我们理解，所以一般都是用链式存储二叉树。

## 二叉树的遍历方式

二叉树主要有两种遍历方式：

1.   深度优先遍历：先往深走，遇到叶子节点再往回走。
     1.   前序遍历（递归法，迭代法）
     2.   中序遍历（递归法，迭代法）
     3.   后序遍历（递归法，迭代法）
2.   广度优先遍历：一层一层的去遍历。
     1.   层序遍历（迭代法）

深度优先遍历中有三个顺序，这里的前中后，其实指的就是中间节点的遍历顺序。

-   前序遍历：中左右
-   中序遍历：左中右
-   后序遍历：左右中

![img](https://qiniucloud.qishilong.space/images/20200806191109896.png)

深度优先遍历的前中后序遍历，使用递归比较方便。

栈其实就是递归的一种实现结构，也就是说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。

广度优先遍历的实现一般使用队列实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的遍历二叉树。

链式存储的二叉树节点定义方式：

```js
class TreeNode {
  constructor(val = undefined, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}
```

二叉树的定义和链表是差不多的，相对于链表，二叉树的节点里多了一个指针，有两个指针，指向左右两个孩子。