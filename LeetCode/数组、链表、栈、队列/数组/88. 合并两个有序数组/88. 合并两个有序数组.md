# 88. 合并两个有序数组

## 题目描述

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

 

示例 1：

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
示例 2：

输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
示例 3：

输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。


提示：

nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109

进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？



## 解法一

```js
var merge = function(nums1, m, nums2, n) {
    let i = m-1, j = n-1;
    for(let k = m+n - 1;k>=0;k--){
        if(i < 0 ||(j >= 0 && nums1[i] <= nums2[j])){
            nums1[k] = nums2[j];
            j--;
        }else {
            nums1[k] = nums1[i];
            i--;
        }
    }
};

// 输入
// nums1: [1,3,5,0,0,0]	m: 3	nums2: [2,4,6] n = 3
// 输出
// [1,2,3,4,5,6]
```

思路：逆序双指针插入

先理清主思路：逆序插入，从后向前遍历传入的两个有序数组，大的放在 `nums1` 的尾部

细节条件：控制指针超出数组的位数，即控制定义的变量 `i` 和 `j` 不能小于0，而且要考虑所有能够进入 `if` 方法的条件，即 `if` 中的

条件应该是 `i < 0 ||(j >= 0 && nums1[i] <= nums2[j])`

时间复杂度：`O(m + n)`

空间复杂度：O(1)

## 解法二

```js
var merge = function(nums1, m, nums2, n) {
    let result = new Array(m+n).fill(0),i = 0,j = 0, current;
    while(i < m || j < n){
        if(i === m){
            current = nums2[j++];
        }else if (j === n){
            current = nums1[i++]
        }else if (nums1[i] < nums2[j]){
            current = nums1[i++]
        }else {
            current = nums2[j++]
        }
        result[i + j -1] = current;
    }
    for(let a = 0; a< m+n;a++){
        nums1[a] = result[a]
    }
};

// 输入
// nums1: [1,3,5,0,0,0]	m: 3	nums2: [2,4,6] n = 3
// 输出
// [1,2,3,4,5,6]
```

思路：正序双指针遍历

先理清主思路：从头遍历传入的两个数组，设定一个临时变量 `current` 和一个新数组 `result` ，如果当前的 `i` 指针直接等于 `nums1` 的长度，则当前的 `current` 直接等于当前 `j` 指针对应的 `nums2` 值，反之相同，如果当前 `i` 指针对应的 `nums1` 值小于当前 `j` 指针对应的 `nums2` 值，则当前 `current` 等于 `nums1[i]` ，否则等于 `nums2[j]` ，然后将 `current` 顺序赋值给 `result` 对应的 `i + j - 1` 下标

细节：1. 要准备一个新数组，将当前 `current` 的值传入新数组，防止传入的两个数组某一值被覆盖。2. 要对 `m === 0 和 n === 0` 的情况做特别处理。

