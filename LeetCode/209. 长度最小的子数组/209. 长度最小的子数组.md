# 209. 长度最小的子数组

## 描述

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

 

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

 

**提示：**

-   `1 <= target <= 109`
-   `1 <= nums.length <= 105`
-   `1 <= nums[i] <= 105`

 

**进阶：**

-   如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

## 代码

### 暴力

```js
/**
 * 暴力两层 for 循环
 * 时间复杂度 O(n^2)
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
  let result = Number.MAX_VALUE;
  let subSum = 0,
    subLength = 0;
  const len = nums.length;
  for (let i = 0; i < len; i++) {
    subSum = 0;
    for (let j = i; j < len; j++) {
      subSum += nums[j];
      if (subSum >= target) {
        subLength = j - i + 1;
        result = result < subLength ? result : subLength;
      }
    }
  }
  return result === Number.MAX_VALUE ? 0 : result;
};

const target = 7,
  nums = [2, 3, 1, 2, 4, 3];
const result = minSubArrayLen(target, nums);
console.log(result);
```

### 滑动窗口

```js
/**
 * 2. 滑动窗口
 * 时间复杂度 O(n)
 * @param {*} target
 * @param {*} nums
 */
var minSubArrayLen = function (target, nums) {
  let slow = 0,
    fast = 0,
    len = nums.length,
    sum = 0,
    subLength = 0,
    result = Number.MAX_VALUE;

  while (fast < len) {
    sum += nums[fast];
    while (sum >= target) {
      subLength = fast - slow + 1;
      result = result < subLength ? result : subLength;
      sum -= nums[slow++];
    }
    fast++;
  }
  return result === Number.MAX_VALUE ? 0 : result;
};

const target = 7,
  nums = [2, 3, 1, 2, 4, 3];
const result = minSubArrayLen(target, nums);
console.log(result);
```

