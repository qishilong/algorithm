# [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

难度简单

给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

-   更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
-   返回 `k` 。

**判题标准:**

系统会用下面的代码来测试你的题解:

```
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有断言都通过，那么您的题解将被 **通过**。

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

**提示：**

-   `1 <= nums.length <= 3 * 104`
-   `-104 <= nums[i] <= 104`
-   `nums` 已按 **升序** 排列

## 代码

```ts
function removeDuplicates(nums: number[]): number {
    let i = 0;
    for(const num of nums){
        if(i< 1|| nums[i-1] !== num){
            nums[i] = num;
            i++
        }
    }
    return i;
};
```

# [80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

难度中等

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

 

**说明：**

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

 

**示例 1：**

```
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。
```

**提示：**

-   `1 <= nums.length <= 3 * 104`
-   `-104 <= nums[i] <= 104`
-   `nums` 已按升序排列

## 代码

```ts
function removeDuplicates(nums: number[]): number {
    let i = 0;
    for(const num of nums){
        if(i< 2|| nums[i-2] !== num){
            nums[i] = num;
            i++
        }
    }
    return i;
};
```

## 题解

### [【举一反二】你真的真的值得学习这精简的代码！！基于双指针，超越双指针！](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solution/ju-yi-fan-er-ni-zhen-de-zhen-de-zhi-de-x-eicz/)



前言
大家好，我是Three~

这道题我在半个多月之前写过，当时有看到一个很巧妙的题解，因此想在这里跟大家分享。在前人的基础上，我加了一些自己的看法。

今天我们要涉及的题目是：力扣80.删除有序数组中的重复项 II和力扣26.删除有序数组中的重复项。

思路与代码
第一题：力扣80.删除有序数组中的重复项 II
我们先从今天的题目开始。

为了引出 “超越一般双指针”的方法 ，我还是需要先介绍双指针解法。

读完题目之后，我们应该注意到：nums数组是有序的！这意味着：相同元素必然连续。
我们可以设置快慢两个指针：fast和slow，运用for循环进行遍历，判断哪些元素应该保留，哪些应该剔除。
具体而言，slow指针表示处理出的数组的长度，fast指针表示已经检查过的数组的长度。即nums[fast]表示待检查的第一个元素，nums[slow − 1]为上一个应该被保留的元素所移动到的指定位置。
因为本题要求相同元素最多出现两次，所以我们需要检查上上个应该被保留的元素nums[slow − 2]是否和当前待检查元素nums[fast]相同。当且仅当nums[slow − 2] == nums[fast]时，当前待检查元素nums[fast]不应该被保留（因为此时必然有nums[slow − 2] == nums[slow − 1] == nums[fast]）。
最后，slow即为处理好的数组的长度。
特别地，数组的前两个数必然可以被保留，因此对于长度不超过2的数组，我们无需进行任何处理，对于长度超过2的数组，我们直接将双指针的初始值设为2即可。
（上面的内容摘自官方题解，因为普通双指针的内容没什么好讲的。）

上面的内容比较抽象，但是结合下面的代码，会很豁然开朗：


class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if (n <= 2) { // 特殊判断，如果nums长度小于2，直接输出长度n即可
            return n;
        }
        int slow = 2, fast = 2; // 因为上面已经做过特殊判别，所以这里快慢指针从2开始
        while (fast < n) {
            if (nums[slow - 2] != nums[fast]) { // 因为题目要求最多两个数相同，所以这么判断
            // 如果nums[slow - 2] == nums[fast]，代表已经有两个数相等，此时nums[fast]
            // 对应的数值不能放进结果之中。反之，如果nums[slow - 2] != nums[fast]，
            // 那么nums[fast]可以放进nums[slow]中，并且slow++，记录结果的长度。
                nums[slow] = nums[fast]; 
                slow++;
            }
            fast++; // 不管怎么样，快指针都是要向前遍历各个元素的
        }
        return slow; // 返回结果的长度，即slow
    }
};
上面的代码也是参考官方题解的，我加上了详细注释，大家理解起来会更舒服些。

相信结合上面的代码和思路讲解，大家对于一般的双指针法应该已经明白了。我就不再赘述了。

接下来，我们来做点有意思的事情。

基于上面显式的双指针法，我们可以进一步抽象简化。

首先应该考虑，我们使用双指针的目的是什么？其实是方便指向我们要使用的数字。所以指针对应的数值才是主角。

在下面的题解中，我们应该尽量少使用指针，让数值自己出来比较：

联想到C++的for循环语法：for (int num : nums)，可以让num自身当右指针；
可以再令一个i代表左指针。
结合上面的思想，我们可以得到下面的代码：

代码


class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int i = 0; // 左指针初始化
        for (int num : nums) { // num当右指针
            if (i < 2 || nums[i - 2] < num) { // i < 2是特殊判断，nums[i - 2] < num
            // 是因为题目要求相同元素不能超过两个。之所以可以用小于号判断，是因为数组是有序的
                nums[i] = num; // 相当于上面官方解法的nums[slow] = nums[fast];
                i++; // 相当于上面官方解法的slow++;，即左指针移动
            }
        }
        return i; // 输出长度，即相当于上面题解的slow
    }
};
代码是不是精简了很多？

有两点我再说一下：

for (int num : nums)是让变量num从左到右遍历一遍nums中所有数值的意思；
把nums[i] = num; i++;改成nums[i++] = num;会更精简，但我相信有些朋友还弄不清楚i++和++i的一些操作，所以我分开写了。不过之前不清楚的朋友们，这次你们要学会咯！
运行结果



效果很好~

如果今天的题解到此为止，那就差点意思。

第二题：力扣26.删除有序数组中的重复项
题目：

给你一个有序数组nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。

示例：

输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

我们发现，跟今天的题目相比，这道题被修改为每个元素只能出现一次。基于上面的第二个思路，我们怎么样最快地求解？

代码


class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int i = 0;
        for (int num : nums) {
            if (i < 1 || nums[i - 1] < num) nums[i++] = num;
        }
        return i;
    }
};
简单来说，把之前的if (i < 2 || nums[i - 2] < num)改成if (i < 1 || nums[i - 1] < num)就好了！

在这里，我们可以进行一个很有意义的拓展：如果每个元素最多出现K次，你要怎么修改上面的代码？

很简单，把if (i < 1 || nums[i - 1] < num)改成if (i < k || nums[i - k] < num)就好了！

学会了这一招，以后遇到这种题目就再也不怕了~这也是这类题目的通解。

（这部分拓展内容的添加要特别鸣谢@空城少年笛卡尔）

运行结果



效果也非常好~

至此，我们今天的两道题就结束了。

小结
我们今天首先学习了一般的双指针解法，接着，我们对于一般方法进行提炼，抽象出超越一般双指针的解法，简洁且高效！这种抓住问题本质并加以抽象的思想，是值得学习的。（是不是感觉整个过程挺magic的~）

碎碎念
一些比较经常看到我的题解的朋友，可能会看到【击双】（其实就是举一反二）和【举一反三】的字样。这是我正在整理的东西，我希望大家在2000多道力扣中可以找到其中的关联，然后更有效地刷题。

欢迎大家关注我!

（因为有学校的事情和我自己才疏学浅，所以没办法保证日日发布题解，还请关注我的同学见谅~~）

结尾
如果你觉得我写得还行，欢迎_关注我_或者_收藏我的题解_或者_给我的题解点赞_。我后续还会持续写题解；
我们下次再见~~

### [【宫水三叶】关于「删除有序数组重复项」的通解](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solution/gong-shui-san-xie-guan-yu-shan-chu-you-x-glnq/)

通用解法
为了让解法更具有一般性，我们将原问题的「保留 2 位」修改为「保留 k 位」。

对于此类问题，我们应该进行如下考虑：

由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留
对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留
举个🌰，我们令 k=2，假设有如下样例

[1,1,1,1,1,1,2,2,2,2,2,2,3]

首先我们先让前 2 位直接保留，得到 1,1
对后面的每一位进行继续遍历，能够保留的前提是与当前位置的前面 k 个元素不同（答案中的第一个 1），因此我们会跳过剩余的 1，将第一个 2 追加，得到 1,1,2
继续这个过程，这时候是和答案中的第 2 个 1 进行对比，因此可以得到 1,1,2,2
这时候和答案中的第 1 个 2 比较，只有与其不同的元素能追加到答案，因此剩余的 2 被跳过，3 被追加到答案：1,1,2,2,3
代码（感谢 @Qian 、@宫水三叶的小迷妹 和 @007 三位同学提供的其他语言版本）：

JavaC++Python3Golang

class Solution {
    public int removeDuplicates(int[] nums) {   
        return process(nums, 2);
    }
    int process(int[] nums, int k) {
        int u = 0; 
        for (int x : nums) {
            if (u < k || nums[u - k] != x) nums[u++] = x;
        }
        return u;
    }
}
时间复杂度：O(n)
空间复杂度：O(1)
其他
这是一种针对「数据有序，相同元素保留 k 位」问题更加本质的解法，该解法是从性质出发提炼的，利用了「数组有序 & 保留逻辑」两大主要性质。

当你掌握这种通解之后，要解决 26. 删除有序数组中的重复项 ，只需要改上述代码一个数字即可（将相同数字保留 2 个修改为保留 1 个）。

这种通解最早我也在 【宫水三叶】「双指针」&「通用」解法 讲过。

# 关于「删除有序数组重复项」的通解

```ts
// 保留 k 项，只需要把 if(i< 1|| nums[i-1] !== num) 这个条件改成 if(i< k|| nums[i-k] !== num) 即可
function removeDuplicates(nums: number[]): number {
    let i = 0;
    for(const num of nums){
        if(i< 1|| nums[i-1] !== num){
            nums[i] = num;
            i++
        }
    }
    return i;
};
```

时间复杂度: O(n)

空间复杂度: O(1)