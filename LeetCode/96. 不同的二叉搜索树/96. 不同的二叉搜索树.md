# 96. 不同的二叉搜索树

## 描述

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。 

**示例 1：**

![img](https://qiniucloud.qishilong.space/images/20250111192428286.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

**提示：**

- `1 <= n <= 19`

## 思路

二叉搜索树是一个有序树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树

了解了二叉搜索树之后，应该先举几个例子，画画图，看看有没有什么规律，如图：

![](https://qiniucloud.qishilong.space/images/20250111195610570.svg)

n为1的时候有一棵树，n为2有两棵树，这个是很直观的。

![](https://qiniucloud.qishilong.space/images/202501112037781.svg)

来看看n为3的时候，有哪几种情况。

当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！

（可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）

当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！

当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！

发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。

思考到这里，这道题目就有眉目了。

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是dp[2]。

有1个元素的搜索树数量就是dp[1]。

有0个元素的搜索树数量就是dp[0]。

所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

如图所示：

![](https://qiniucloud.qishilong.space/images/202501112038547.svg)

此时我们已经找到递推关系了，那么可以用动规五部曲再系统分析一遍。

1. 确定dp数组（dp table）以及下标的含义

   **dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。

   也可以理解是i个不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。

   以下分析如果想不清楚，就来回想一下dp[i]的定义

2. 确定递推公式

   在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

   j相当于是头结点的元素，从1遍历到i为止。

   所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

3. dp数组如何初始化

   初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。

   那么dp[0]应该是多少呢？

   从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。

   从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。

   所以初始化dp[0] = 1

4. 确定遍历顺序

   首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。

   那么遍历i里面每一个数作为头结点的状态，用j来遍历。

   代码如下：

   ```js
   for (let i = 4; i <= n; i++) {
     for (let j = 1; j <= i; j++) {
       dp[i] += dp[j - 1] * dp[i - j];
     }
   }
   ```

5. 举例推导dp数组

   n为5时候的dp数组状态如图：

   ![](https://qiniucloud.qishilong.space/images/202501112043048.svg)

   当然如果自己画图举例的话，基本举例到n为3就可以了，n为4的时候，画图已经比较麻烦了。

   综上分析完毕，js代码如下：

   ```js
   /**
    * 1. 动态规划
    * dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]
    * @param {number} n
    * @return {number}
    */
   var numTrees = function (n) {
     if (!n) {
       return n;
     }
     if (n === 1) {
       return 1;
     }
     if (n === 2) {
       return 2;
     }
     if (n === 3) {
       return 5;
     }
   
     // 初始化dp数组
     const dp = new Array(n + 1).fill(null);
     // 初始化n<=3之前的dp数组的值
     dp[0] = 1;
     dp[1] = 1;
     dp[2] = 2;
     dp[3] = 5;
   
     for (let i = 4; i <= n; i++) {
       for (let j = 1; j <= i; j++) {
         /**
          * 对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加
          * 一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
          */
         dp[i] += dp[j - 1] * dp[i - j];
       }
     }
   
     return dp[n];
   };
   ```

   - 时间复杂度：$O(n^2)$
   - 空间复杂度：$O(n)$

## 总结

这道题目虽然在力扣上标记是中等难度，但可以算是困难了！

首先这道题想到用动规的方法来解决，就不太好想，需要举例，画图，分析，才能找到递推的关系。

然后难点就是确定递推公式了，如果把递推公式想清楚了，遍历顺序和初始化，就是自然而然的事情了。

## 代码

### 动态规划

```js
/**
 * 1. 动态规划
 * dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]
 * @param {number} n
 * @return {number}
 */
var numTrees = function (n) {
  if (!n) {
    return n;
  }
  if (n === 1) {
    return 1;
  }
  if (n === 2) {
    return 2;
  }
  if (n === 3) {
    return 5;
  }

  // 初始化dp数组
  const dp = new Array(n + 1).fill(null);
  // 初始化n<=3之前的dp数组的值
  dp[0] = 1;
  dp[1] = 1;
  dp[2] = 2;
  dp[3] = 5;

  for (let i = 4; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      /**
       * 对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加
       * 一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
       */
      dp[i] += dp[j - 1] * dp[i - j];
    }
  }

  return dp[n];
};
```